<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- order: 3 -->
    <!-- icon: ðŸ“ -->
    <title>Recursive TextSplitter</title>
    <meta name="description" content="å±•ç¤º LangChain é€’å½’æ–‡æœ¬åˆ†å‰²ç®—æ³•çš„å·¥ä½œåŽŸç†ï¼Œå¸®åŠ©ç†è§£å¦‚ä½•å°†é•¿æ–‡æœ¬é€’å½’åœ°åˆ†å‰²ä¸ºå¤šä¸ªå­æ–‡æœ¬å—ã€‚">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap');
        body { font-family: 'Segoe UI', sans-serif; }
        .code-font { font-family: 'JetBrains Mono', monospace; }
        
        /* Tree Lines */
        .tree-children {
            position: relative;
            padding-left: 20px;
            margin-left: 10px;
            border-left: 2px dashed #e2e8f0;
        }
        
        /* Node Animations */
        .node-enter { animation: slideIn 0.3s ease-out forwards; }
        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .highlight-active {
            box-shadow: 0 0 0 2px #3b82f6;
            border-color: #3b82f6 !important;
            background-color: #eff6ff !important;
        }

        .highlight-recurse {
            box-shadow: 0 0 0 2px #f59e0b;
            border-color: #f59e0b !important;
            background-color: #fffbeb !important;
        }

        /* Code Highlighting */
        .code-line {
            padding-left: 12px;
            border-left: 3px solid transparent;
            opacity: 0.6;
            transition: all 0.1s;
        }
        .code-line.active-line {
            background-color: #374151; /* slate-700 */
            border-left-color: #fbbf24; /* amber-400 */
            opacity: 1;
            color: white;
        }

        /* Scrollbars */
        .custom-scrollbar::-webkit-scrollbar { width: 6px; height: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        
        /* Dark Scrollbar for left panel */
        .dark-scrollbar::-webkit-scrollbar-thumb { background: #475569; }
        .dark-scrollbar::-webkit-scrollbar-thumb:hover { background: #64748b; }

        /* Invisible Char Visuals */
        .char-nl::before { content: "â†µ"; color: #94a3b8; margin-right: 2px; }
        .char-sp::before { content: "Â·"; color: #cbd5e1; font-weight: bold; }
        
        /* Syntax Highlighting Colors */
        .syn-k { color: #c678dd; } /* keyword */
        .syn-f { color: #61afef; } /* function */
        .syn-s { color: #98c379; } /* string */
        .syn-c { color: #7f848e; font-style: italic; } /* comment */
        .syn-v { color: #e06c75; } /* variable */

        /* Merge Animation Helpers */
        .merge-item-pop { animation: popOut 0.3s ease-in forwards; }
        @keyframes popOut {
            to { opacity: 0; transform: scale(0.8) translateY(-10px); }
        }
        .merge-active-border { border-color: #f59e0b !important; background-color: #fffbeb !important; }
        
        /* Buffer Item Consume Animation */
        .buffer-consume { animation: consumeOut 0.2s ease-in forwards; }
        @keyframes consumeOut {
            to { opacity: 0; transform: translateY(10px) scale(0.9); }
        }
    </style>
</head>
<body class="bg-slate-50 h-screen flex flex-col overflow-hidden text-slate-800">

    <!-- Header -->
    <header class="bg-white border-b border-slate-200 h-14 flex items-center justify-between px-6 flex-shrink-0 z-30 shadow-sm">
        <div class="flex items-center gap-3">
            <div class="bg-blue-600 p-1.5 rounded text-white shadow-sm">
                <i data-lucide="git-fork" class="w-5 h-5"></i>
            </div>
            <div>
                <h1 class="text-lg font-bold text-slate-800 leading-none">RecursiveCharacterTextSplitter</h1>
                <div class="text-[10px] text-slate-400 font-mono mt-0.5">é€’å½’å­—ç¬¦æ–‡æœ¬åˆ†å‰²å™¨</div>
            </div>
            <!-- GitHub Repo stars -->
            <a
              href="https://github.com/vsme/ai-viz"
              target="_blank"
              rel="noopener noreferrer"
            >
              <img
                src="//img.shields.io/github/stars/vsme/ai-viz"
                alt="GitHub Repo stars"
              />
            </a>
        </div>
        <div class="flex items-center gap-4">
            <div class="flex items-center gap-2 text-xs font-medium text-slate-500 bg-slate-100 px-3 py-1.5 rounded-full">
                <span class="w-2 h-2 rounded-full bg-slate-400" id="status-dot"></span>
                <span id="status-text">Idle</span>
            </div>
        </div>
    </header>

    <div class="flex-1 flex overflow-hidden">
        
        <!-- LEFT: Algorithm & Log -->
        <aside class="w-[450px] bg-[#1e1e1e] flex flex-col border-r border-slate-800 flex-shrink-0 z-20 text-slate-300">
            <!-- Code Header -->
            <div class="px-3 py-2 bg-[#252526] border-b border-black flex justify-between items-center text-[10px] font-bold uppercase tracking-wider text-slate-500">
                <span>Algorithm (Python Logic)</span>
                <i data-lucide="code-2" class="w-3 h-3"></i>
            </div>
            
            <!-- Code Body -->
            <div id="code-container" class="flex-1 overflow-auto py-2 font-mono text-[11px] leading-5 custom-scrollbar dark-scrollbar">
                <div id="ln-def" class="code-line"><span class="syn-k">def</span> <span class="syn-f">_split_text</span>(text, separators):</div>
                <div id="ln-sep" class="code-line pl-4"><span class="syn-c"># 1. Choose Separator</span></div>
                <div id="ln-sep-logic" class="code-line pl-4">separator = <span class="syn-f">get_separator</span>(text, separators)</div>
                <div class="code-line">&nbsp;</div>
                <div id="ln-split" class="code-line pl-4"><span class="syn-c"># 2. Split Text</span></div>
                <div id="ln-split-call" class="code-line pl-4">splits = text.<span class="syn-f">split</span>(separator)</div>
                <div id="ln-init-buf" class="code-line pl-4">_good_splits = []</div>
                <div class="code-line">&nbsp;</div>
                <div id="ln-loop" class="code-line pl-4"><span class="syn-c"># 3. Iterate Splits</span></div>
                <div id="ln-loop-for" class="code-line pl-4"><span class="syn-k">for</span> s <span class="syn-k">in</span> splits:</div>
                <div id="ln-check-len" class="code-line pl-8"><span class="syn-k">if</span> <span class="syn-f">len</span>(s) < chunk_size:</div>
                <div id="ln-add-buf" class="code-line pl-12">_good_splits.<span class="syn-f">append</span>(s)</div>
                <div id="ln-else" class="code-line pl-8"><span class="syn-k">else</span>:</div>
                <div class="code-line pl-12"><span class="syn-c"># If buffer has items, we MUST flush them</span></div>
                <div class="code-line pl-12"><span class="syn-c"># before processing the big chunk 's'</span></div>
                <div id="ln-check-buf" class="code-line pl-12"><span class="syn-k">if</span> _good_splits:</div>
                <div id="ln-flush-mid" class="code-line pl-16"><span class="syn-f">merge_splits</span>(_good_splits, separator)</div>
                <div id="ln-clear-buf" class="code-line pl-16">_good_splits = []</div>
                <div class="code-line">&nbsp;</div>
                <div id="ln-recurse-check" class="code-line pl-12"><span class="syn-c"># 4. Recursion on big chunk</span></div>
                <div id="ln-recurse-if" class="code-line pl-12"><span class="syn-k">if</span> new_separators:</div>
                <div id="ln-recurse-call" class="code-line pl-16"><span class="syn-f">_split_text</span>(s, new_separators)</div>
                <div id="ln-force-else" class="code-line pl-12"><span class="syn-k">else</span>:</div>
                <div id="ln-force-emit" class="code-line pl-16"><span class="syn-f">force_emit</span>(s)</div>
                <div class="code-line">&nbsp;</div>
                <div id="ln-final-check" class="code-line pl-4"><span class="syn-c"># 5. Flush Remaining</span></div>
                <div id="ln-final-if" class="code-line pl-4"><span class="syn-k">if</span> _good_splits:</div>
                <div id="ln-final-flush" class="code-line pl-8"><span class="syn-f">merge_splits</span>(_good_splits, separator)</div>
                
                <div class="code-line">&nbsp;</div>
                <div class="border-t border-slate-700 my-1 mx-2"></div>
                <div class="code-line">&nbsp;</div>

                <!-- Merge Splits Visualization -->
                <div id="ln-merge-def" class="code-line"><span class="syn-k">def</span> <span class="syn-f">merge_splits</span>(splits, separator):</div>
                <div id="ln-merge-init" class="code-line pl-4">current_doc, total = [], 0</div>
                <div id="ln-merge-loop" class="code-line pl-4"><span class="syn-k">for</span> d <span class="syn-k">in</span> splits:</div>
                <div id="ln-merge-check" class="code-line pl-8"><span class="syn-k">if</span> total + <span class="syn-f">len</span>(d) > chunk_size:</div>
                <div id="ln-merge-emit" class="code-line pl-12"><span class="syn-f">emit_chunk</span>(current_doc)</div>
                <div id="ln-merge-overlap" class="code-line pl-12"><span class="syn-k">while</span> total > overlap: </div>
                <div class="code-line pl-16">current_doc.<span class="syn-f">pop</span>(0)</div>
                <div id="ln-merge-append" class="code-line pl-8">current_doc.<span class="syn-f">append</span>(d)</div>
                <div id="ln-merge-final" class="code-line pl-4"><span class="syn-f">emit_chunk</span>(current_doc)</div>
            </div>

            <!-- Log Header -->
            <div class="px-3 py-2 bg-[#252526] border-y border-black flex justify-between items-center text-[10px] font-bold uppercase tracking-wider text-slate-500 mt-auto">
                <span>Execution Log</span>
                <span id="step-counter" class="font-mono">Step: 0</span>
            </div>
            <!-- Log Body -->
            <div id="console-log" class="h-48 overflow-auto p-3 font-mono text-[10px] space-y-1 custom-scrollbar dark-scrollbar bg-[#1e1e1e]">
                <div class="text-slate-500 italic">Ready to split...</div>
            </div>
        </aside>

        <!-- CENTER: Visualization -->
        <main class="flex-1 flex flex-col min-w-0 bg-slate-50 relative">
            
            <!-- Visualization Container -->
            <div class="flex-1 overflow-auto p-6 custom-scrollbar" id="tree-container">
                <div id="tree-root" class="pb-20"></div>
            </div>

            <!-- Bottom Panel: _good_splits Buffer & Final Output -->
            <div class="h-[420px] bg-white border-t border-slate-200 flex flex-col shadow-[0_-4px_20px_-5px_rgba(0,0,0,0.1)] z-20 transition-all">
                
                <!-- Buffer Section (Fixed height) -->
                <div class="h-32 border-b border-slate-100 flex flex-col flex-shrink-0">
                    <div class="px-4 py-1.5 bg-slate-50 border-b border-slate-100 flex justify-between items-center">
                        <span class="text-[10px] font-bold text-slate-500 uppercase tracking-wider flex items-center gap-2">
                            <i data-lucide="layers" class="w-3 h-3"></i> _good_splits (Input Buffer)
                        </span>
                    </div>
                    <div id="buffer-area" class="flex-1 p-3 flex flex-wrap gap-x-2 overflow-x-auto custom-scrollbar items-start bg-slate-50/50">
                        <div id="buffer-placeholder" class="text-xs text-slate-300 italic px-2">Buffer is empty</div>
                    </div>
                </div>

                <!-- Merge Sandbox (New Visualization) -->
                <div class="h-32 border-b border-slate-100 flex flex-col flex-shrink-0 bg-amber-50/30">
                    <div class="px-4 py-1.5 border-b border-slate-100 flex justify-between items-center">
                        <span class="text-[10px] font-bold text-amber-600 uppercase tracking-wider flex items-center gap-2">
                            <i data-lucide="git-merge" class="w-3 h-3"></i> Merge Process (Accumulator)
                        </span>
                        <div class="flex items-center gap-2">
                            <span id="merge-total" class="text-[10px] font-mono bg-amber-100 text-amber-700 px-1.5 rounded border border-amber-200">Length: 0</span>
                        </div>
                    </div>
                    <div id="merge-area" class="flex-1 p-3 flex flex-wrap gap-x-2 overflow-x-auto custom-scrollbar items-start">
                        <div id="merge-placeholder" class="text-xs text-slate-300 italic px-2 w-full text-center">Waiting for merge_splits()...</div>
                    </div>
                </div>

                <!-- Final Chunks Section (Takes remaining space) -->
                <div class="flex-1 flex flex-col min-h-0 bg-white">
                    <div class="px-4 py-1.5 border-b border-slate-100 flex justify-between items-center">
                        <span class="text-[10px] font-bold text-blue-600 uppercase tracking-wider flex items-center gap-2">
                            <i data-lucide="package-check" class="w-3 h-3"></i> Final Chunks
                        </span>
                        <span id="chunk-count" class="text-[10px] font-mono bg-blue-100 text-blue-700 px-1.5 rounded">0 chunks</span>
                    </div>
                    <div id="final-chunks-area" class="flex-1 p-4 flex gap-4 overflow-x-auto custom-scrollbar items-start content-start">
                        <!-- Final chunks go here -->
                    </div>
                </div>
            </div>
        </main>

        <!-- RIGHT: Controls -->
        <aside class="w-[280px] bg-white border-l border-slate-200 flex flex-col z-30 shadow-xl">
            <div class="p-5 space-y-5 bg-slate-50 h-full overflow-y-auto custom-scrollbar">
                
                <!-- Text Input -->
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <label class="text-xs font-bold text-slate-700 uppercase">Input Text</label>
                        <button id="btn-load-sample" class="text-[10px] text-blue-600 hover:underline cursor-pointer">Load Sample</button>
                    </div>
                    <textarea id="input-text" class="w-full h-32 p-2  custom-scrollbar border border-slate-300 rounded text-xs code-font resize-none focus:ring-2 focus:ring-blue-500 outline-none" spellcheck="false"></textarea>
                </div>

                <!-- Sliders -->
                <div class="space-y-4">
                    <div>
                        <div class="flex justify-between mb-1">
                            <label class="text-[10px] font-bold text-slate-500">Chunk Size</label>
                            <span id="val-size" class="text-[10px] font-mono font-bold text-blue-600">100</span>
                        </div>
                        <input type="range" id="range-size" min="10" max="500" value="100" class="w-full h-1 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
                    </div>
                    <div>
                        <div class="flex justify-between mb-1">
                            <label class="text-[10px] font-bold text-slate-500">Overlap</label>
                            <span id="val-overlap" class="text-[10px] font-mono font-bold text-amber-600">20</span>
                        </div>
                        <input type="range" id="range-overlap" min="0" max="100" value="20" class="w-full h-1 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-amber-500">
                    </div>
                </div>

                <!-- Playback Controls -->
                <div class="grid grid-cols-2 gap-2 pt-2">
                    <button id="btn-reset" class="col-span-2 bg-white border border-slate-300 hover:bg-slate-50 text-slate-700 py-1.5 rounded flex justify-center items-center gap-2 text-xs font-bold transition-colors">
                        <i data-lucide="rotate-ccw" class="w-3 h-3"></i> Reset
                    </button>
                    <button id="btn-step" class="bg-blue-100 hover:bg-blue-200 text-blue-700 border border-blue-200 py-1.5 rounded flex justify-center items-center gap-2 text-xs font-bold transition-colors">
                        <i data-lucide="step-forward" class="w-3 h-3"></i> Step
                    </button>
                    <button id="btn-play" class="bg-blue-600 hover:bg-blue-700 text-white border border-blue-600 py-1.5 rounded flex justify-center items-center gap-2 text-xs font-bold shadow-sm transition-all active:scale-95">
                        <i data-lucide="play" class="w-3 h-3 fill-current"></i> Play
                    </button>
                </div>
            </div>
        </aside>

    </div>

    <!-- Templates -->
    <template id="node-template">
        <div class="node-item mb-2">
            <div class="node-content flex items-start gap-2 group">
                <!-- Connector -->
                <div class="mt-2 w-2 h-2 rounded-full border border-slate-300 bg-white z-10 flex-shrink-0 transition-colors duration-200"></div>
                
                <!-- Card -->
                <div class="node-card border border-slate-200 bg-white rounded p-2 shadow-sm min-w-[200px] max-w-[90%] transition-all duration-300">
                    <div class="flex justify-between items-center mb-1 pb-1 border-b border-slate-100">
                        <div class="flex items-center gap-2">
                            <span class="separator-badge text-[9px] font-bold px-1.5 py-0.5 rounded bg-slate-100 text-slate-500 border border-slate-200">ROOT</span>
                            <span class="length-badge text-[9px] font-mono text-slate-400">0 chars</span>
                        </div>
                        <span class="status-badge text-[9px] font-bold px-1 rounded hidden"></span>
                    </div>
                    <div class="text-content font-mono text-[11px] leading-relaxed text-slate-700 break-words whitespace-pre-wrap bg-slate-50 p-1 rounded border border-slate-100/50"></div>
                </div>
            </div>
            <!-- Children Container -->
            <div class="tree-children hidden"></div>
        </div>
    </template>

    <script>
        // --- CONSTANTS & CONFIG ---
        const SAMPLE_TEXT = `Artificial Intelligence (AI) is intelligence demonstrated by machines, as opposed to intelligence of humans and other animals. 

Example tasks in which this is done include speech recognition, computer vision, translation between (natural) languages, as well as other mappings of inputs.

As machines become increasingly capable, tasks considered to require "intelligence" are often removed from the definition of AI, a phenomenon known as the AI effect.`;

        const SEPARATORS = ["\n\n", "\n", " ", ""]; 

        // --- STATE MANAGEMENT ---
        let state = {
            text: "",
            chunkSize: 100,
            overlap: 20,
            trace: [],
            currentStep: -1,
            isPlaying: false,
            timer: null,
            nodeMap: new Map() // ID -> DOM Element
        };

        // --- DOM ELEMENTS ---
        const els = {
            inputText: document.getElementById('input-text'),
            rangeSize: document.getElementById('range-size'),
            valSize: document.getElementById('val-size'),
            rangeOverlap: document.getElementById('range-overlap'),
            valOverlap: document.getElementById('val-overlap'),
            treeRoot: document.getElementById('tree-root'),
            bufferArea: document.getElementById('buffer-area'),
            bufferPlaceholder: document.getElementById('buffer-placeholder'),
            mergeArea: document.getElementById('merge-area'),
            mergeTotal: document.getElementById('merge-total'),
            mergePlaceholder: document.getElementById('merge-placeholder'),
            finalChunksArea: document.getElementById('final-chunks-area'),
            console: document.getElementById('console-log'),
            stepCounter: document.getElementById('step-counter'),
            statusDot: document.getElementById('status-dot'),
            statusText: document.getElementById('status-text'),
            chunkCount: document.getElementById('chunk-count'),
            btnPlay: document.getElementById('btn-play'),
            btnStep: document.getElementById('btn-step'),
            btnReset: document.getElementById('btn-reset'),
            btnLoad: document.getElementById('btn-load-sample'),
            codeContainer: document.getElementById('code-container')
        };

        // --- HELPERS ---
        function formatTextForDisplay(text) {
            if (!text) return '';
            let safeText = text.replace(/</g, '&lt;').replace(/>/g, '&gt;');
            // Visualize spaces and newlines
            safeText = safeText.replace(/\n/g, '<span class="char-nl"></span><br>');
            safeText = safeText.replace(/ /g, '<span class="char-sp"></span>');
            return safeText;
        }

        // --- LOGIC SIMULATION (Trace Generator) ---

        let traceIdCounter = 0;
        const nextId = () => `node-${traceIdCounter++}`;

        function generateTrace(text, chunkSize, chunkOverlap) {
            const trace = [];
            
            function record(type, payload) {
                trace.push({ type, payload });
            }

            // Mock of LangChain _merge_splits
            function mergeSplits(splits, separator, reason) {
                record('HIGHLIGHT_CODE', { line: 'ln-merge-def' });
                record('HIGHLIGHT_CODE', { line: 'ln-merge-init' });
                record('MERGE_START', {}); // Reset/Show merge area
                
                record('LOG', { msg: `Merging ${splits.length} items (${reason})...`, color: reason === 'flush_mid' ? 'text-amber-300' : 'text-blue-300' });
                
                let currentDoc = [];
                let total = 0;
                const sepLen = separator ? separator.length : 0;

                for (let i = 0; i < splits.length; i++) {
                    const d = splits[i];
                    record('HIGHLIGHT_CODE', { line: 'ln-merge-loop' });
                    const len = d.length;
                    
                    record('HIGHLIGHT_CODE', { line: 'ln-merge-check' });
                    // Check logic
                    if (total + len + (currentDoc.length > 0 ? sepLen : 0) > chunkSize) {
                        if (currentDoc.length > 0) {
                            record('HIGHLIGHT_CODE', { line: 'ln-merge-emit' });
                            const docStr = currentDoc.join(separator);
                            record('EMIT_CHUNK', { text: docStr, len: docStr.length });
                            
                            // Visualize Popping
                            while (total > chunkOverlap || (total + len + sepLen > chunkSize && total > 0)) {
                                record('HIGHLIGHT_CODE', { line: 'ln-merge-overlap' });
                                const popped = currentDoc.shift();
                                const popLen = popped.length + sepLen;
                                total -= popLen;
                                // We simulate the visualization update
                                record('MERGE_POP', { text: popped, newTotal: total });
                            }
                        }
                    }
                    
                    record('HIGHLIGHT_CODE', { line: 'ln-merge-append' });
                    currentDoc.push(d);
                    total += len + (currentDoc.length > 1 ? sepLen : 0);
                    // Add index i to payload so UI can target correct buffer item
                    record('MERGE_ADD', { text: d, len: len, newTotal: total, isLast: i === splits.length - 1 });
                }
                
                record('HIGHLIGHT_CODE', { line: 'ln-merge-final' });
                if (currentDoc.length > 0) {
                    const docStr = currentDoc.join(separator);
                    record('EMIT_CHUNK', { text: docStr, len: docStr.length });
                }
                
                record('MERGE_END', {});
            }

            // The Core Recursive Logic
            function _split_text(text, separators, parentId) {
                record('HIGHLIGHT_CODE', { line: 'ln-def' });
                const myId = nextId();
                record('CREATE_NODE', { id: myId, parentId, text, levelSep: separators[0] || 'char' });
                record('HIGHLIGHT_NODE', { id: myId, type: 'active' });

                // 1. Find Separator
                record('HIGHLIGHT_CODE', { line: 'ln-sep-logic' });
                let separator = separators[separators.length - 1];
                let newSeparators = [];
                
                for (let i = 0; i < separators.length; i++) {
                    const s = separators[i];
                    if (s === "") {
                        separator = s;
                        break;
                    }
                    if (text.includes(s)) {
                        separator = s;
                        newSeparators = separators.slice(i + 1);
                        break;
                    }
                }

                // 2. Split
                record('HIGHLIGHT_CODE', { line: 'ln-split-call' });
                const displaySep = separator === '\n\n' ? '\\n\\n' : separator === '\n' ? '\\n' : separator === ' ' ? 'SPC' : 'char';
                record('LOG', { msg: `Splitting by [${displaySep}]` });
                
                let splits = text.split(separator);
                
                record('HIGHLIGHT_CODE', { line: 'ln-init-buf' });
                let goodSplits = [];

                // 3. Iterate
                record('HIGHLIGHT_CODE', { line: 'ln-loop-for' });
                for (let s of splits) {
                    if(!s) continue;
                    
                    record('HIGHLIGHT_CODE', { line: 'ln-check-len' });
                    if (s.length < chunkSize) {
                        // Good Split -> Buffer
                        record('HIGHLIGHT_CODE', { line: 'ln-add-buf' });
                        goodSplits.push(s);
                        record('ADD_TO_BUFFER', { text: s });
                    } else {
                        record('HIGHLIGHT_CODE', { line: 'ln-else' });
                        // Bad Split (Too Big)
                        record('HIGHLIGHT_CODE', { line: 'ln-check-buf' });
                        if (goodSplits.length > 0) {
                            // Flush buffer first
                            record('HIGHLIGHT_CODE', { line: 'ln-flush-mid' });
                            record('FLUSH_BUFFER', { separator });
                            
                            // Specific Log for Middle Flush
                            record('LOG', { msg: `Hit large chunk. Flushing buffer first.`, color: 'text-amber-400' });
                            mergeSplits(goodSplits, separator, 'flush_mid');
                            
                            record('HIGHLIGHT_CODE', { line: 'ln-clear-buf' });
                            goodSplits = [];
                        }
                        
                        // Recurse on the big chunk
                        record('HIGHLIGHT_CODE', { line: 'ln-recurse-if' });
                        if (newSeparators.length === 0) {
                            record('HIGHLIGHT_CODE', { line: 'ln-force-else' });
                            record('HIGHLIGHT_CODE', { line: 'ln-force-emit' });
                            record('LOG', { msg: `No separators left. Forcing chunk.`, color: 'text-red-400' });
                            record('EMIT_CHUNK', { text: s, len: s.length });
                        } else {
                            record('HIGHLIGHT_CODE', { line: 'ln-recurse-call' });
                            record('LOG', { msg: `Chunk too big (${s.length}). Recursing...`, color: 'text-amber-300' });
                            record('HIGHLIGHT_NODE', { id: myId, type: 'recurse' });
                            _split_text(s, newSeparators, myId);
                            record('HIGHLIGHT_NODE', { id: myId, type: 'active' }); // Focus back
                        }
                    }
                }

                // End of loop flush
                record('HIGHLIGHT_CODE', { line: 'ln-final-check' });
                record('HIGHLIGHT_CODE', { line: 'ln-final-if' });
                if (goodSplits.length > 0) {
                    record('HIGHLIGHT_CODE', { line: 'ln-final-flush' });
                    record('FLUSH_BUFFER', { separator });
                    record('LOG', { msg: `Loop done. Flushing remaining items.`, color: 'text-blue-300' });
                    mergeSplits(goodSplits, separator, 'flush_final');
                }

                record('COMPLETE_NODE', { id: myId });
            }

            // Start
            record('LOG', { msg: '--- STARTED ---', color: 'text-green-400 font-bold' });
            _split_text(text, SEPARATORS, null);
            record('LOG', { msg: '--- FINISHED ---', color: 'text-green-400 font-bold' });
            
            return trace;
        }


        // --- UI RENDERERS ---

        function highlightCodeLine(lineId) {
            document.querySelectorAll('.active-line').forEach(el => el.classList.remove('active-line'));
            if (!lineId) return;
            const el = document.getElementById(lineId);
            if (el) {
                el.classList.add('active-line');
                el.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        function renderNode(payload) {
            const tmpl = document.getElementById('node-template');
            const clone = tmpl.content.cloneNode(true);
            const el = clone.querySelector('.node-item');
            
            el.id = payload.id;
            
            // Text Content (Truncated)
            let displayTxt = payload.text;
            if(displayTxt.length > 60) displayTxt = displayTxt.substring(0, 60) + "...";
            
            // Format for display
            displayTxt = formatTextForDisplay(displayTxt);
            
            el.querySelector('.text-content').innerHTML = displayTxt;
            el.querySelector('.length-badge').innerText = `${payload.text.length} chars`;

            // Separator Badge
            const sepEl = el.querySelector('.separator-badge');
            let sepLabel = payload.levelSep;
            if (sepLabel === '\n\n') sepLabel = '\\n\\n';
            else if (sepLabel === '\n') sepLabel = '\\n';
            else if (sepLabel === ' ') sepLabel = 'SPACE';
            else if (sepLabel === '') sepLabel = 'CHAR';
            
            sepEl.innerText = sepLabel;

            // Append to DOM
            if (!payload.parentId) {
                els.treeRoot.appendChild(el);
            } else {
                const parent = document.getElementById(payload.parentId);
                if (parent) {
                    const container = parent.querySelector('.tree-children');
                    container.classList.remove('hidden');
                    container.appendChild(el);
                }
            }
            
            // Animate entry
            el.querySelector('.node-card').classList.add('node-enter');
            
            // Scroll into view
            setTimeout(() => {
                el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }, 50);

            state.nodeMap.set(payload.id, el);
        }

        function highlightNode(payload) {
            // Remove previous highlights
            document.querySelectorAll('.highlight-active').forEach(el => el.classList.remove('highlight-active'));
            
            const node = document.getElementById(payload.id);
            if(!node) return;
            
            const card = node.querySelector('.node-card');
            
            if (payload.type === 'active') {
                card.classList.add('highlight-active');
            } else if (payload.type === 'recurse') {
                card.classList.add('highlight-recurse');
            }
        }

        function completeNode(payload) {
            const node = document.getElementById(payload.id);
            if(!node) return;
            const card = node.querySelector('.node-card');
            card.classList.remove('highlight-active', 'highlight-recurse');
            card.style.opacity = '0.6';
            
            const status = node.querySelector('.status-badge');
            status.classList.remove('hidden');
            status.innerText = "PROCESSED";
            status.classList.add('text-green-600', 'bg-green-100');
        }

        function updateBuffer(payload) {
            const item = document.createElement('div');
            item.className = 'buffer-item flex-shrink-0 bg-amber-100 border border-amber-200 text-amber-800 text-[10px] px-2 py-1 rounded font-mono whitespace-nowrap animate-pulse';
            
            // Truncate logic inside format helper is tricky, simple truncate raw text first
            let rawTxt = payload.text;
            if(rawTxt.length > 15) rawTxt = rawTxt.substring(0, 15) + '...';
            item.innerHTML = `"${formatTextForDisplay(rawTxt)}"`;
            
            // Clear "Empty" msg if first item
            if(els.bufferPlaceholder.style.display !== 'none') els.bufferPlaceholder.style.display = 'none';
            
            els.bufferArea.appendChild(item);
            els.bufferArea.scrollLeft = els.bufferArea.scrollWidth;
        }

        function flushBuffer(payload) {
            // Non-destructive now, logic moved to MERGE_ADD
            // Just maybe visually indicate start of flush
        }

        function mergeStart() {
            els.mergeArea.innerHTML = ''; // Clear placeholder
            els.mergeTotal.innerText = 'Length: 0';
            els.mergeTotal.classList.remove('bg-red-100', 'text-red-700', 'border-red-200');
            els.mergeTotal.classList.add('bg-amber-100', 'text-amber-700', 'border-amber-200');
        }

        function mergeAdd(payload) {
            // 1. Consume from Buffer (Visual transfer)
            const bufferItem = els.bufferArea.querySelector('.buffer-item');
            if (bufferItem) {
                // Animate removal logic if desired, or simple remove
                bufferItem.remove();
            }

            // 2. Add to Merge Area
            const item = document.createElement('div');
            item.className = 'flex-shrink-0 bg-white border border-amber-300 text-amber-900 text-[10px] px-2 py-1 rounded font-mono shadow-sm node-enter merge-active-border';
            let rawTxt = payload.text;
            if(rawTxt.length > 15) rawTxt = rawTxt.substring(0, 15) + '...';
            item.innerHTML = `"${formatTextForDisplay(rawTxt)}"`;
            item.dataset.fulltext = payload.text;
            
            els.mergeArea.appendChild(item);
            els.mergeArea.scrollLeft = els.mergeArea.scrollWidth;
            
            els.mergeTotal.innerText = `Length: ${payload.newTotal}`;
            
            if (payload.newTotal > state.chunkSize) {
                 els.mergeTotal.classList.replace('bg-amber-100', 'bg-red-100');
                 els.mergeTotal.classList.replace('text-amber-700', 'text-red-700');
                 els.mergeTotal.classList.replace('border-amber-200', 'border-red-200');
            }
        }

        function mergePop(payload) {
            const firstItem = els.mergeArea.firstElementChild;
            if (firstItem) {
                firstItem.classList.add('merge-item-pop');
                setTimeout(() => {
                    if(firstItem.parentNode) firstItem.parentNode.removeChild(firstItem);
                }, 290);
            }
            els.mergeTotal.innerText = `Length: ${payload.newTotal}`;
             if (payload.newTotal <= state.chunkSize) {
                 els.mergeTotal.classList.replace('bg-red-100', 'bg-amber-100');
                 els.mergeTotal.classList.replace('text-red-700', 'text-amber-700');
                 els.mergeTotal.classList.replace('border-red-200', 'border-amber-200');
            }
        }

        function mergeEnd() {
            // Restore placeholder if buffer is empty
            if (els.bufferArea.children.length === 1 && els.bufferPlaceholder) {
                els.bufferPlaceholder.style.display = 'block';
            }
            // Keep the last state of merge visible for a moment, or reset
            // els.mergeArea.innerHTML = '<div id="merge-placeholder" class="text-xs text-slate-300 italic px-2 w-full text-center">Waiting for merge_splits()...</div>';
        }

        function emitChunk(payload) {
            const chunk = document.createElement('div');
            chunk.className = 'flex-shrink-0 w-64 h-full bg-white border border-blue-200 rounded p-2 flex flex-col shadow-sm node-enter transition-all hover:shadow-md hover:border-blue-400';
            
            let displayTxt = formatTextForDisplay(payload.text);
            
            chunk.innerHTML = `
                <div class="flex justify-between items-center border-b border-blue-100 pb-1 mb-1">
                    <span class="text-[9px] font-bold text-blue-600">CHUNK ${els.finalChunksArea.children.length + 1}</span>
                    <span class="text-[9px] font-mono text-slate-400">${payload.len}c</span>
                </div>
                <div class="flex-1 overflow-auto text-[11px] text-slate-600 font-mono custom-scrollbar leading-relaxed bg-slate-50 p-2 rounded whitespace-pre-wrap break-words">${displayTxt}</div>
            `;
            els.finalChunksArea.appendChild(chunk);
            els.chunkCount.innerText = `${els.finalChunksArea.children.length} chunks`;
            
            // Flash latest
            chunk.classList.add('ring-2', 'ring-blue-400');
            setTimeout(() => chunk.classList.remove('ring-2', 'ring-blue-400'), 500);
            
            els.finalChunksArea.scrollLeft = els.finalChunksArea.scrollWidth;
        }

        function appendLog(payload) {
            const line = document.createElement('div');
            line.className = `border-l-2 pl-2 border-slate-700 ${payload.color || 'text-slate-400'}`;
            line.innerHTML = `<span class="opacity-50 text-[9px] mr-2">[${state.currentStep}]</span>${payload.msg}`;
            els.console.appendChild(line);
            els.console.scrollTop = els.console.scrollHeight;
        }

        // --- CONTROLLER ---

        function processStep(stepObj) {
            const { type, payload } = stepObj;
            
            switch(type) {
                case 'HIGHLIGHT_CODE': highlightCodeLine(payload.line); break;
                case 'CREATE_NODE': renderNode(payload); break;
                case 'HIGHLIGHT_NODE': highlightNode(payload); break;
                case 'COMPLETE_NODE': completeNode(payload); break;
                case 'ADD_TO_BUFFER': updateBuffer(payload); break;
                case 'FLUSH_BUFFER': flushBuffer(payload); break;
                case 'MERGE_START': mergeStart(); break;
                case 'MERGE_ADD': mergeAdd(payload); break;
                case 'MERGE_POP': mergePop(payload); break;
                case 'MERGE_END': mergeEnd(); break;
                case 'EMIT_CHUNK': emitChunk(payload); break;
                case 'LOG': appendLog(payload); break;
            }
        }

        function step() {
            if (state.currentStep < state.trace.length - 1) {
                state.currentStep++;
                processStep(state.trace[state.currentStep]);
                els.stepCounter.innerText = `Step: ${state.currentStep + 1} / ${state.trace.length}`;
            } else {
                stop();
                setStatus("Complete", "bg-green-500");
            }
        }

        function play() {
            if (state.isPlaying) return;
            state.isPlaying = true;
            els.btnPlay.innerHTML = `<i data-lucide="pause" class="w-3 h-3 fill-current"></i> Pause`;
            lucide.createIcons();
            els.btnPlay.classList.replace('bg-blue-600', 'bg-amber-600');
            els.btnPlay.classList.replace('border-blue-600', 'border-amber-600');
            
            setStatus("Running", "bg-green-500 animate-pulse");
            
            state.timer = setInterval(() => {
                if(state.currentStep >= state.trace.length - 1) {
                    stop();
                } else {
                    step();
                }
            }, 100); // Speed
        }

        function stop() {
            state.isPlaying = false;
            clearInterval(state.timer);
            els.btnPlay.innerHTML = `<i data-lucide="play" class="w-3 h-3 fill-current"></i> Play`;
            lucide.createIcons();
            els.btnPlay.classList.replace('bg-amber-600', 'bg-blue-600');
            els.btnPlay.classList.replace('border-amber-600', 'border-blue-600');
            
            if(state.currentStep < state.trace.length - 1) setStatus("Paused", "bg-amber-400");
            else setStatus("Complete", "bg-green-500");
        }

        function reset() {
            stop();
            state.currentStep = -1;
            state.nodeMap.clear();
            traceIdCounter = 0;
            
            // Clear DOM
            els.treeRoot.innerHTML = '';
            els.bufferPlaceholder.style.display = 'block';
            els.bufferArea.innerHTML = '';
            els.bufferArea.appendChild(els.bufferPlaceholder);
            
            els.mergeArea.innerHTML = '<div id="merge-placeholder" class="text-xs text-slate-300 italic px-2 w-full text-center">Waiting for merge_splits()...</div>';
            els.finalChunksArea.innerHTML = '';
            els.console.innerHTML = '';
            els.chunkCount.innerText = '0 chunks';
            els.stepCounter.innerText = 'Step: 0';
            els.mergeTotal.innerText = 'Length: 0';
            els.mergeTotal.className = 'text-[10px] font-mono bg-amber-100 text-amber-700 px-1.5 rounded border border-amber-200';
            
            highlightCodeLine(null);
            
            // Regenerate Trace
            state.text = els.inputText.value;
            state.chunkSize = parseInt(els.rangeSize.value);
            state.overlap = parseInt(els.rangeOverlap.value);
            
            state.trace = generateTrace(state.text, state.chunkSize, state.overlap);
            
            setStatus("Ready", "bg-blue-400");
            appendLog({ msg: "Simulation reset. Press Play." });
        }

        function setStatus(text, colorClass) {
            els.statusText.innerText = text;
            els.statusDot.className = `w-2 h-2 rounded-full ${colorClass}`;
        }

        // --- EVENT LISTENERS ---
        els.btnReset.addEventListener('click', reset);
        els.btnStep.addEventListener('click', () => { stop(); step(); });
        els.btnPlay.addEventListener('click', () => { state.isPlaying ? stop() : play(); });
        
        els.btnLoad.addEventListener('click', () => {
            els.inputText.value = SAMPLE_TEXT;
            reset();
        });

        const updateConfig = () => {
            els.valSize.innerText = els.rangeSize.value;
            els.valOverlap.innerText = els.rangeOverlap.value;
            reset();
        };

        els.rangeSize.addEventListener('input', updateConfig);
        els.rangeOverlap.addEventListener('input', updateConfig);
        els.inputText.addEventListener('change', reset);

        // --- INIT ---
        lucide.createIcons();
        els.inputText.value = SAMPLE_TEXT;
        reset();

    </script>
</body>
</html>