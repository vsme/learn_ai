<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LangChain TextSplitter 全流程可视化 (详细版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap');
        body { font-family: 'Segoe UI', sans-serif; }
        .code-font { font-family: 'JetBrains Mono', monospace; }
        
        /* Tree Connector Lines */
        .tree-children {
            position: relative;
            padding-left: 24px;
            margin-left: 12px;
            border-left: 2px dashed #e2e8f0;
        }
        
        /* Node Styles */
        .node-card {
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0.5;
            transform: scale(0.98);
            border-width: 1px;
        }
        .node-visible { opacity: 1; transform: scale(1); }
        .node-active {
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3);
            border-color: #3b82f6 !important;
            opacity: 1 !important;
            z-index: 10;
            background-color: #fff;
        }
        .node-ignored {
            opacity: 0.4 !important;
            background-color: #f3f4f6 !important;
            border-color: #d1d5db !important;
            color: #9ca3af !important;
        }
        .node-ignored .node-content { text-decoration: line-through; }
        
        /* Phase Highlights */
        .node-merging {
            box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.4);
            border-color: #f59e0b !important;
            background-color: #fffbeb !important;
            opacity: 1 !important;
        }

        /* Code Highlighting */
        .code-line {
            padding: 0 12px;
            border-left: 3px solid transparent;
            opacity: 0.4;
            transition: all 0.1s;
            line-height: 1.5;
        }
        .code-line.active {
            background-color: #374151;
            border-left-color: #fbbf24;
            color: #fff;
            opacity: 1;
            font-weight: 600;
        }

        /* Animations */
        @keyframes slideInRight {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        @keyframes popOut {
            to { opacity: 0; transform: scale(0.8) translateY(-20px); }
        }
        .buffer-enter { animation: slideInRight 0.3s ease-out forwards; }
        .buffer-exit { animation: popOut 0.3s ease-in forwards; }

        /* Invisible Characters */
        .invis-char { color: #cbd5e1; font-weight: bold; display: inline-block; user-select: none; }
        .char-newline::before { content: "↵"; }
        .char-space::before { content: "·"; }

        /* Custom Scrollbar */
        .custom-scrollbar::-webkit-scrollbar { width: 6px; height: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
    </style>
</head>
<body class="bg-slate-50 h-screen flex flex-col overflow-hidden text-slate-800">

    <!-- App Header -->
    <header class="bg-white border-b border-slate-200 h-14 flex items-center justify-between px-6 flex-shrink-0 z-30 shadow-sm relative">
        <div class="flex items-center gap-3">
            <div class="bg-blue-600 p-1.5 rounded text-white shadow-sm">
                <i data-lucide="layers" class="w-5 h-5"></i>
            </div>
            <h1 class="text-lg font-bold text-slate-800 tracking-tight">LangChain <span class="text-slate-400 font-normal">TextSplitter Visualizer</span></h1>
            <!-- GitHub Repo stars -->
            <a
              href="https://github.com/vsme/ai-viz"
              target="_blank"
              rel="noopener noreferrer"
            >
              <img
                src="//img.shields.io/github/stars/vsme/ai-viz"
                alt="GitHub Repo stars"
              />
            </a>
        </div>
        <div class="flex items-center gap-3">
            <div class="text-xs font-mono text-slate-400 bg-slate-100 px-2 py-1 rounded">RecursiveCharacterTextSplitter</div>
            <div class="h-4 w-px bg-slate-300 mx-1"></div>
            <div class="flex items-center gap-2">
                <span class="w-2 h-2 rounded-full bg-green-500 animate-pulse" id="status-dot"></span>
                <span class="text-sm font-medium text-slate-600" id="status-text">Ready</span>
            </div>
        </div>
    </header>

    <!-- Main Layout -->
    <div class="flex-1 flex overflow-hidden">
        
        <!-- LEFT: Code & Log -->
        <aside class="w-[400px] bg-[#1e1e1e] flex flex-col border-r border-slate-800 text-slate-300 shadow-xl z-20 flex-shrink-0">
            <!-- Code Panel -->
            <div class="flex-1 flex flex-col min-h-0 border-b border-black">
                <div class="p-2 bg-[#252526] text-[10px] font-bold text-slate-400 uppercase tracking-wider flex justify-between items-center border-b border-[#333]">
                    <span>Algorithm Logic (Python)</span>
                    <i data-lucide="code-2" class="w-3 h-3"></i>
                </div>
                <div class="flex-1 overflow-auto py-3 code-font text-[11px]" id="code-container">
                    <!-- Phase 1: Recursive Split -->
                    <div class="px-4 text-slate-500 font-bold mb-1"># 1. RECURSIVE SPLITTING</div>
                    <div id="line-def" class="code-line"><span class="text-purple-400">def</span> <span class="text-yellow-300">recursive_split</span>(text, seps):</div>
                    <div id="line-base-check" class="code-line pl-4"><span class="text-green-400">if not</span> seps:</div>
                    
                    <div id="line-base-ret" class="code-line pl-8 bg-blue-900/20 border-l-2 border-blue-500 text-blue-100"><span class="text-slate-400"># Force Split (with overlap logic)</span></div>
                    <div id="line-base-ret-2" class="code-line pl-8 bg-blue-900/20 border-l-2 border-blue-500 text-blue-100"><span class="text-purple-400">return</span> [text[i : i + size]...]</div>
                    
                    <div id="line-sep" class="code-line pl-4">sep = seps[0]</div>
                    <div id="line-split" class="code-line pl-4">splits = text.<span class="text-yellow-300">split</span>(sep)</div>
                    <div id="line-reattach" class="code-line pl-4"><span class="text-slate-500"># Re-attach separators</span></div>
                    <div id="line-reattach-logic" class="code-line pl-4">splits = [s+sep <span class="text-purple-400">if</span> i &lt; len-1 <span class="text-purple-400">else</span> s ...]</div>
                    
                    <div id="line-loop" class="code-line pl-4"><span class="text-purple-400">for</span> split <span class="text-purple-400">in</span> splits:</div>
                    <div id="line-check-len" class="code-line pl-8"><span class="text-green-400">if</span> len(split) > chunk_size:</div>
                    <div id="line-recurse-call" class="code-line pl-12">res.extend(<span class="text-yellow-300">recurse</span>(split, seps[1:]))</div>
                    <div id="line-else" class="code-line pl-8"><span class="text-green-400">else</span>:</div>
                    <div id="line-append" class="code-line pl-12">res.append(split)</div>
                    
                    <!-- Phase 2: Filtering -->
                    <div class="px-4 text-slate-500 font-bold mb-1 mt-3"># 2. FILTERING</div>
                    <div id="line-strip" class="code-line border-l-2 border-green-600 bg-green-900/10 text-green-100">final_splits = [s <span class="text-purple-400">for</span> s <span class="text-purple-400">in</span> res <span class="text-purple-400">if</span> s.strip()]</div>

                    <!-- Phase 3: Merging -->
                    <div class="px-4 text-slate-500 font-bold mb-1 mt-3"># 3. MERGING (BUFFER)</div>
                    <div id="line-merge-init" class="code-line">buffer = [], current_len = 0</div>
                    <div id="line-merge-loop" class="code-line"><span class="text-purple-400">for</span> split <span class="text-purple-400">in</span> final_splits:</div>
                    <div id="line-merge-check" class="code-line pl-4"><span class="text-green-400">if</span> current_len + len(split) > size:</div>
                    
                    <div id="line-redundant-check" class="code-line pl-8 text-amber-200 opacity-80"><span class="text-gray-500"># Optim: Skip if redundant</span></div>
                    <div id="line-emit" class="code-line pl-8"><span class="text-blue-400">if</span> len > overlap: <span class="text-blue-400">yield</span> buffer</div>
                    
                    <div id="line-overlap-loop" class="code-line pl-8"><span class="text-purple-400">while</span> current_len > overlap:</div>
                    <div id="line-overlap-pop" class="code-line pl-12">buffer.pop(0) <span class="text-slate-500"># Shrink from start</span></div>
                    
                    <div id="line-buffer-add" class="code-line pl-4">buffer.append(split)</div>
                </div>
            </div>
            
            <!-- Console Log -->
            <div class="h-1/3 bg-[#0d0d0d] flex flex-col">
                <div class="p-2 bg-[#1a1a1a] text-[10px] font-bold text-slate-500 uppercase tracking-wider flex justify-between items-center border-b border-[#333]">
                    <span>Execution Log</span>
                    <i data-lucide="terminal" class="w-3 h-3"></i>
                </div>
                <div id="console-log" class="flex-1 overflow-auto p-3 font-mono text-[10px] leading-relaxed text-slate-400 custom-scrollbar">
                    <div class="text-slate-600 italic">Ready. Click "Run" to start.</div>
                </div>
            </div>
        </aside>

        <!-- CENTER: Visualization Stage -->
        <main class="flex-1 flex flex-col overflow-hidden bg-slate-50 relative shadow-inner">

            <!-- Visual Tree Container -->
            <div class="relative flex-1 overflow-auto p-8 custom-scrollbar" id="visualization-container">
                <div id="tree-root" class="min-w-fit pb-32"></div>
            </div>
            
            <!-- Legend Overlay -->
            <div class="absolute left-4 bottom-[calc(1.5rem+13rem)] flex flex-col gap-2 text-[10px] font-medium z-10 bg-white/90 backdrop-blur p-3 rounded-lg border border-slate-200 shadow-sm select-none pointer-events-none">
                <div class="font-bold text-slate-400 uppercase text-[9px] tracking-wider mb-1">Split Phase</div>
                <div class="flex items-center gap-2"><div class="w-2 h-2 rounded-full bg-yellow-400"></div>Processing</div>
                <div class="flex items-center gap-2"><div class="w-2 h-2 rounded-full bg-yellow-100 border border-yellow-400"></div>Split (Used Separator)</div>
                <div class="flex items-center gap-2"><div class="w-2 h-2 rounded-full bg-blue-100 border border-blue-500"></div>FORCE (Hard Cut)</div>
                <div class="flex items-center gap-2"><div class="w-2 h-2 rounded-full bg-green-500"></div>Accepted Leaf</div>
                
                <div class="mt-2 font-bold text-slate-400 uppercase text-[9px] tracking-wider mb-1">Merge Phase</div>
                <div class="flex items-center gap-2"><div class="w-2 h-2 rounded-full border-2 border-amber-500 bg-amber-50"></div>Active in Buffer</div>
            </div>

            <!-- Bottom Panel: Merging Buffer -->
            <div class="bg-white border-t border-slate-200 h-52 flex flex-col shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.05)] z-20">
                <!-- Buffer Header -->
                <div class="h-9 bg-slate-50 border-b border-slate-100 flex items-center justify-between px-4 text-xs select-none">
                    <div class="flex items-center gap-6">
                        <span class="font-bold text-slate-600 uppercase flex items-center gap-2">
                            <i data-lucide="container" class="w-3.5 h-3.5 text-slate-400"></i> 
                            Merge Buffer
                        </span>
                        <div class="flex items-center gap-3 text-[11px] bg-white border border-slate-200 rounded px-2 py-1">
                            <span class="text-slate-400">Size:</span>
                            <span id="buffer-size" class="font-mono font-bold text-blue-600">0</span>
                            <span class="text-slate-300">/</span>
                            <span id="target-size" class="font-mono text-slate-600 font-bold">50</span>
                            <span class="text-[9px] text-slate-400 ml-1 uppercase">Limit</span>
                        </div>
                        <div class="flex items-center gap-2 text-[11px]">
                            <span class="text-slate-400">Overlap ></span>
                            <span id="overlap-size" class="font-mono text-amber-600 font-bold bg-amber-50 px-1.5 rounded border border-amber-100">10</span>
                        </div>
                    </div>
                    <span class="font-bold text-slate-600 uppercase flex items-center gap-2">
                        <i data-lucide="package-check" class="w-3.5 h-3.5 text-slate-400"></i> 
                        Final Chunks
                    </span>
                </div>

                <!-- Buffer & Results Content -->
                <div class="flex-1 flex overflow-hidden">
                    <!-- Active Buffer Area -->
                    <div class="w-[340px] border-r border-slate-200 bg-slate-50/30 relative flex flex-col p-3">
                        
                        <!-- Limit Indicator Line -->
                        <div class="absolute top-0 bottom-0 right-0 w-1 bg-slate-200/50 z-0"></div>
                        <div class="absolute bottom-2 right-2 text-[9px] text-slate-300 font-bold uppercase rotate-180" style="writing-mode: vertical-rl;">Max Size</div>

                        <div id="buffer-container" class="flex-1 flex flex-wrap content-start gap-1.5 overflow-y-auto custom-scrollbar z-10 pr-2">
                            <div class="text-slate-400 text-xs italic w-full text-center mt-10" id="buffer-placeholder">Waiting for merge phase...</div>
                        </div>

                        <!-- Overlap Zone Visual -->
                        <div id="overlap-indicator" class="mt-2 h-6 border-t border-dashed border-amber-300 bg-amber-50 flex items-center justify-center text-[9px] text-amber-700 font-medium opacity-0 transition-opacity">
                            Overlap Logic Active (Popping...)
                        </div>
                    </div>

                    <!-- Result List -->
                    <div class="flex-1 p-4 bg-white overflow-x-auto custom-scrollbar flex items-center gap-4" id="final-chunks-container">
                        <!-- Chunks appear here -->
                    </div>
                </div>
            </div>
        </main>

        <!-- RIGHT: Control Panel -->
        <aside class="w-[280px] bg-white border-l border-slate-200 flex flex-col z-30 flex-shrink-0">
            <!-- Controls -->
            <div class="p-4 border-b border-slate-100 bg-slate-50">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xs font-bold text-slate-500 uppercase tracking-wider">Controls</h2>
                    <div class="text-[10px] font-mono text-slate-400" id="step-counter">Step: 0</div>
                </div>
                
                <div class="grid grid-cols-1 gap-2 mb-3">
                    <!-- <button id="btn-start" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-2 rounded shadow-sm flex items-center justify-center gap-2 text-xs font-bold uppercase tracking-wide transition-all active:scale-95">
                        <i data-lucide="play" class="w-3 h-3 fill-current"></i> Run
                    </button> -->
                    <button id="btn-reset" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-2 rounded shadow-sm flex items-center justify-center gap-2 text-xs font-bold uppercase tracking-wide transition-all active:scale-95">
                        <i data-lucide="rotate-ccw" class="w-3 h-3"></i> Reset
                    </button>
                </div>

                <div class="grid grid-cols-2 gap-2">
                    <button id="btn-prev" disabled class="px-2 py-1.5 bg-white border border-slate-300 text-slate-600 rounded text-xs font-medium hover:bg-slate-50 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">
                        &larr; Prev
                    </button>
                    <button id="btn-next" disabled class="px-2 py-1.5 bg-white border border-slate-300 text-slate-600 rounded text-xs font-medium hover:bg-slate-50 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">
                        Next &rarr;
                    </button>
                </div>
                
                <div class="mt-3 flex items-center gap-2 justify-center">
                    <label for="auto-play" class="text-xs text-slate-500 font-medium cursor-pointer select-none">Auto Play</label>
                    <input type="checkbox" id="auto-play" class="rounded text-blue-600 focus:ring-blue-500 border-slate-300 w-4 h-4">
                </div>
            </div>

            <!-- Configuration -->
            <div class="p-5 flex-1 overflow-y-auto custom-scrollbar space-y-6">
                
                <div class="space-y-4">
                    <!-- Chunk Size -->
                    <div>
                        <div class="flex justify-between mb-1.5">
                            <label class="text-xs font-bold text-slate-600">Chunk Size</label>
                            <span id="chunk-size-val" class="text-xs font-mono bg-blue-50 text-blue-700 px-1.5 rounded border border-blue-100 font-bold">50</span>
                        </div>
                        <input type="range" id="chunk-size-input" min="20" max="200" value="50" step="5" class="w-full h-1.5 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
                    </div>

                    <!-- Overlap -->
                    <div>
                        <div class="flex justify-between mb-1.5">
                            <label class="text-xs font-bold text-slate-600">Chunk Overlap</label>
                            <span id="chunk-overlap-val" class="text-xs font-mono bg-amber-50 text-amber-700 px-1.5 rounded border border-amber-100 font-bold">10</span>
                        </div>
                        <input type="range" id="chunk-overlap-input" min="0" max="50" value="10" step="5" class="w-full h-1.5 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-amber-500">
                        <p class="text-[10px] text-slate-400 mt-1 leading-tight">
                            Retains characters from previous chunk context. Must be &lt; Chunk Size.
                        </p>
                    </div>
                </div>

                <hr class="border-slate-100">

                <!-- Input -->
                <div>
                    <div class="flex flex-col justify-between mb-2">
                        <label class="text-xs font-bold text-slate-600 uppercase tracking-wider mb-2">Input Text</label>
                        <div class="flex flex-wrap gap-1 text-[10px] text-slate-400">
                            <span class="bg-slate-100 px-1.5 py-0.5 rounded">\n\n</span>
                            <span class="bg-slate-100 px-1.5 py-0.5 rounded">\n</span>
                            <span class="bg-slate-100 px-1.5 py-0.5 rounded">.</span>
                            <span class="bg-slate-100 px-1.5 py-0.5 rounded">。</span>
                            <span class="bg-slate-100 px-1.5 py-0.5 rounded">,</span>
                            <span class="bg-slate-100 px-1.5 py-0.5 rounded">，</span>
                            <span class="bg-slate-100 px-1.5 py-0.5 rounded">SPC</span>
                        </div>
                    </div>
                    <textarea id="input-text" class="w-full h-40 p-3 border border-slate-300 rounded-md text-xs code-font resize-none focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none leading-relaxed text-slate-600 bg-slate-50 transition-shadow" spellcheck="false"></textarea>
                </div>

            </div>
        </aside>

    </div>

    <script>
        // --- CONFIGURATION ---
        const DEFAULT_TEXT = `This is paragraph one. It is about forty-six characters long.\n\nThis is paragraph two. It is also forty-six characters long.`;
        
        // LangChain Default Separators
        const SEPARATORS = ["\n\n", "\n", ".", "。", ",", "，", " "]; 

        // --- STATE ---
        let appState = {
            chunkSize: 50,
            chunkOverlap: 10,
            inputText: DEFAULT_TEXT,
            trace: [],       
            currentStep: -1, 
            nodes: {},       
            autoPlayInterval: null
        };

        // --- DOM ELEMENTS ---
        const elInputText = document.getElementById('input-text');
        const elChunkSizeInput = document.getElementById('chunk-size-input');
        const elChunkSizeVal = document.getElementById('chunk-size-val');
        const elChunkOverlapInput = document.getElementById('chunk-overlap-input');
        const elChunkOverlapVal = document.getElementById('chunk-overlap-val');
        const elTreeRoot = document.getElementById('tree-root');
        const elBufferContainer = document.getElementById('buffer-container');
        const elFinalChunksContainer = document.getElementById('final-chunks-container');
        const elConsoleLog = document.getElementById('console-log');
        const elStepCounter = document.getElementById('step-counter');
        const elStatusText = document.getElementById('status-text');
        const elStatusDot = document.getElementById('status-dot');
        const elBufferSize = document.getElementById('buffer-size');
        const elTargetSize = document.getElementById('target-size');
        const elOverlapSize = document.getElementById('overlap-size');
        const elBufferPlaceholder = document.getElementById('buffer-placeholder');
        const elOverlapIndicator = document.getElementById('overlap-indicator');
        
        // const btnStart = document.getElementById('btn-start');
        const btnReset = document.getElementById('btn-reset');
        const btnPrev = document.getElementById('btn-prev');
        const btnNext = document.getElementById('btn-next');
        const chkAutoPlay = document.getElementById('auto-play');

        // --- HELPERS ---
        function visualizeWhitespace(text) {
            if (!text) return "";
            
            // 1. Escape HTML entities first to protect raw strings like '<'
            const safeText = text
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");

            // 2. Safely replace whitespace with visual spans
            return safeText.replace(/(\n| )/g, function(match) {
                return match === "\n" 
                    ? '<span class="invis-char char-newline"></span><br>' 
                    : '<span class="invis-char char-space"></span> ';
            });
        }

        function log(msg, type="info") {
            const div = document.createElement('div');
            let borderClass = "border-slate-700";
            let textClass = "text-slate-400";
            
            if (type === "error") { borderClass = "border-red-500"; textClass = "text-red-400"; }
            if (type === "success") { borderClass = "border-green-500"; textClass = "text-green-400"; }
            if (type === "bold") { textClass = "text-blue-300 font-bold"; }

            div.className = `mb-1 border-l-2 pl-2 ${borderClass} ${textClass} leading-snug`;
            div.innerHTML = `<span class="text-slate-600 text-[9px] mr-1 opacity-50">[${appState.currentStep+1}]</span> ${msg}`;
            elConsoleLog.appendChild(div);
            elConsoleLog.scrollTop = elConsoleLog.scrollHeight;
        }

        // --- TRACER LOGIC (The Brain) ---
        
        function generateTrace(text, chunkSize, chunkOverlap) {
            let trace = [];
            let nodeIdCounter = 0;
            let nodes = {};

            const nextId = () => `node-${nodeIdCounter++}`;

            function record(action, nodeId, codeLineId, payload = {}) {
                trace.push({
                    stepIndex: trace.length,
                    action,     
                    nodeId,
                    codeLineId,
                    payload
                });
            }

            // PHASE 1: Recursive Split
            function recursiveSplit(txt, seps, parentId = null) {
                const myId = nextId();
                nodes[myId] = { id: myId, text: txt, parentId, children: [], status: 'pending' };
                record('CREATE', myId, 'line-def', { text: txt, parentId });
                
                record('FOCUS', myId, 'line-base-check');
                // Base case: No separators left -> Force split
                if (seps.length === 0) {
                    record('STATUS_CHANGE', myId, 'line-base-ret', { status: 'forced' });
                    record('LOG', null, null, { msg: "FORCE: No separators left. Hard cutting text with stride.", type: 'error' });
                    
                    let leaves = [];
                    const stride = chunkSize - chunkOverlap;
                    
                    for (let i = 0; i < txt.length; i += stride) {
                        const chunkTxt = txt.slice(i, i + chunkSize);
                        
                        if (chunkTxt.length > 0) {
                            const childId = nextId();
                            nodes[childId] = { id: childId, text: chunkTxt, parentId: myId, children: [], status: 'forced' };
                            record('CREATE', childId, 'line-base-ret-2', { text: chunkTxt, parentId: myId, isForced: true });
                            leaves.push(nodes[childId]);
                            if (i + chunkSize >= txt.length) break;
                        }
                    }
                    return leaves;
                }

                // Split Attempt
                const sep = seps[0];
                record('FOCUS', myId, 'line-sep', { separator: sep });
                record('FOCUS', myId, 'line-split');
                
                let rawSplits = txt.split(sep);
                
                // FIX: Separator Re-attachment Logic
                record('FOCUS', myId, 'line-reattach');
                let parts = [];
                for (let i = 0; i < rawSplits.length; i++) {
                    let p = rawSplits[i];
                    if (i < rawSplits.length - 1) {
                        p += sep;
                    }
                    if (p.length > 0) parts.push(p);
                }
                
                record('LOG', myId, 'line-reattach-logic', { 
                    msg: `Splitting by "${sep.replace(/\n/g,'\\n')}". Result: ${parts.length} parts.` 
                });

                record('FOCUS', myId, 'line-loop');
                let leaves = [];
                
                for (let part of parts) {
                    record('FOCUS', myId, 'line-check-len', { currentPartLength: part.length });
                    
                    if (part.length > chunkSize) {
                        record('LOG', myId, 'line-recurse-call', { msg: `Part too long (${part.length}). Recursing...`, type: 'error' });
                        // Update parent status to SPLIT here, pass separator
                        record('STATUS_CHANGE', myId, 'line-loop', { status: 'split', separator: sep }); 
                        
                        const childLeaves = recursiveSplit(part, seps.slice(1), myId);
                        leaves.push(...childLeaves);
                    } else {
                        // Fits -> Accepted Leaf
                        const leafId = nextId();
                        nodes[leafId] = { id: leafId, text: part, parentId: myId, children: [], status: 'accepted' };
                        record('CREATE', leafId, 'line-append', { text: part, parentId: myId, status: 'accepted' });
                        record('STATUS_CHANGE', myId, 'line-else', { status: 'split', separator: sep }); 
                        leaves.push(nodes[leafId]);
                    }
                }
                return leaves;
            }

            // Run Phase 1
            record('LOG', null, null, { msg: "--- PHASE 1: SPLITTING TREE ---", type: 'bold' });
            const rawLeaves = recursiveSplit(text, SEPARATORS);

            // PHASE 2: Filtering
            record('LOG', null, 'line-strip', { msg: "--- FILTERING ---", type: 'bold' });
            const finalLeaves = [];
            for (let leaf of rawLeaves) {
                if (leaf.text.trim().length === 0) {
                    record('IGNORE_NODE', leaf.id, 'line-strip', { msg: `Ignored empty/whitespace node ${leaf.id}` });
                } else {
                    finalLeaves.push(leaf);
                }
            }

            // PHASE 3: Merging
            record('LOG', null, 'line-merge-def', { msg: "--- PHASE 2: MERGING & OVERLAP ---", type: 'bold' });
            
            let currentDoc = [];
            let currentLen = 0;
            
            record('LOG', null, 'line-merge-init', { msg: `Initializing buffer. Max: ${chunkSize}, Overlap: ${chunkOverlap}` });

            for (let leaf of finalLeaves) {
                record('FOCUS', leaf.id, 'line-merge-loop'); 
                record('MERGE_HIGHLIGHT', leaf.id, 'line-merge-loop', { msg: `Merging leaf: "${leaf.text.substring(0,10).replace(/\n/g,'\\n')}..."` });
                
                record('FOCUS', null, 'line-merge-check');
                
                if (currentLen + leaf.text.length > chunkSize) {
                    
                    const shouldEmit = currentLen > chunkOverlap; 
                    
                    if (shouldEmit) {
                        record('LOG', null, 'line-merge-check', { msg: `Buffer limit reached (${currentLen}). Emitting.`, type: 'bold' });
                        const chunkText = currentDoc.map(l => l.text).join('');
                        if (chunkText.length > 0) {
                            record('EMIT_CHUNK', null, 'line-emit', { text: chunkText, len: currentLen });
                        }
                    } else {
                        record('LOG', null, 'line-redundant-check', { 
                            msg: `Skipping emit (Subset redundancy).`, 
                            type: 'success' 
                        });
                    }
                    
                    record('FOCUS', null, 'line-overlap-loop', { msg: `Adjusting buffer for overlap...` });
                    
                    while (currentLen > chunkOverlap && currentDoc.length > 0) {
                        const removed = currentDoc.shift();
                        currentLen -= removed.text.length;
                        record('BUFFER_POP', removed.id, 'line-overlap-pop', { 
                            removedId: removed.id, 
                            newLen: currentLen,
                            msg: `Popped head.` 
                        });
                        // Visualizing the edge case: Context Loss
                        if (currentLen === 0) {
                             record('LOG', null, 'line-overlap-loop', { 
                                msg: "⚠️ Context lost: Segment larger than overlap window.", 
                                type: 'error' 
                            });
                        }
                    }
                }

                currentDoc.push(leaf);
                currentLen += leaf.text.length;
                record('BUFFER_ADD', leaf.id, 'line-buffer-add', { 
                    leafId: leaf.id, 
                    text: leaf.text, 
                    newLen: currentLen 
                });
            }

            if (currentDoc.length > 0) {
                const chunkText = currentDoc.map(l => l.text).join('');
                record('EMIT_CHUNK', null, 'line-emit', { text: chunkText, len: currentLen });
            }

            return { trace, nodes };
        }

        // --- RENDERER & PLAYBACK ---

        function highlightCodeLine(lineId) {
            document.querySelectorAll('.code-line').forEach(el => el.classList.remove('active'));
            if (lineId) {
                const el = document.getElementById(lineId);
                if (el) {
                    el.classList.add('active');
                    el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
        }

        function createDomNode(nodeId, data) {
            if (document.getElementById(nodeId)) return;

            const el = document.createElement('div');
            el.id = nodeId;
            el.className = 'node-card mb-2 min-w-[120px]'; 
            
            let displayTxt = visualizeWhitespace(data.text);
            if (data.text.length > 40) displayTxt = visualizeWhitespace(data.text.substring(0, 40)) + '<span class="text-slate-400">...</span>';

            let borderColor = 'border-slate-200';
            let badgeHtml = '';

            if (data.status === 'forced') {
                borderColor = 'border-blue-300 bg-blue-50';
                badgeHtml = `<span class="text-[9px] font-bold text-blue-600 bg-blue-100 px-1 rounded" title="Hard cut by char count">FORCE</span>`;
            } else if (data.status === 'accepted') {
                borderColor = 'border-green-300 bg-green-50';
                badgeHtml = `<span class="text-[9px] font-bold text-green-600 bg-green-100 px-1 rounded">OK</span>`;
            } else if (data.status === 'pending') {
                borderColor = 'border-yellow-300 bg-yellow-50';
            }

            el.innerHTML = `
                <div class="border ${borderColor} rounded p-2 shadow-sm text-xs relative bg-white">
                    <div class="flex justify-between items-center mb-1 border-b border-black/5 pb-1">
                        <span class="font-mono text-slate-500 text-[10px]">${data.text.length} chars</span>
                        <div id="badge-${nodeId}" class="flex gap-1">${badgeHtml}</div>
                    </div>
                    <div class="font-mono text-slate-700 leading-snug break-all text-[11px]">${displayTxt}</div>
                </div>
                <div id="children-${nodeId}" class="tree-children hidden"></div>
            `;

            if (data.parentId) {
                const parentChildrenContainer = document.getElementById(`children-${data.parentId}`);
                if (parentChildrenContainer) {
                    parentChildrenContainer.classList.remove('hidden');
                    parentChildrenContainer.appendChild(el);
                }
            } else {
                elTreeRoot.appendChild(el);
            }
            requestAnimationFrame(() => el.classList.add('node-visible'));
        }

        function updateNodeStatus(nodeId, status, separator) {
            const el = document.getElementById(nodeId);
            if (!el) return;
            const inner = el.firstElementChild;
            const badge = document.getElementById(`badge-${nodeId}`);

            inner.className = "border rounded p-2 shadow-sm text-xs relative bg-white"; 

            if (status === 'too_long') {
                inner.classList.add('border-red-300', 'bg-red-50');
                badge.innerHTML = `<span class="text-red-600 bg-red-100 px-1 rounded font-bold text-[9px]">LONG</span>`;
            } else if (status === 'accepted') {
                inner.classList.add('border-green-300', 'bg-green-50');
                badge.innerHTML = `<span class="text-green-600 bg-green-100 px-1 rounded font-bold text-[9px]">OK</span>`;
            } else if (status === 'split') {
                inner.classList.add('border-yellow-300', 'bg-yellow-50');
                // Format separator for display
                let sepDisplay = separator;
                if(sepDisplay === '\n\n') sepDisplay = '\\n\\n';
                else if(sepDisplay === '\n') sepDisplay = '\\n';
                else if(sepDisplay === ' ') sepDisplay = 'SPC';
                
                badge.innerHTML = `<span class="text-yellow-700 bg-yellow-100 px-1 rounded font-bold text-[9px]" title="Split by this separator">Split: ${sepDisplay}</span>`;
            } else if (status === 'forced') {
                inner.classList.add('border-blue-300', 'bg-blue-50');
                badge.innerHTML = `<span class="text-blue-600 bg-blue-100 px-1 rounded font-bold text-[9px]" title="Force Split: No valid separators found">FORCE</span>`;
            }
        }

        function highlightMergingNode(nodeId) {
            document.querySelectorAll('.node-merging').forEach(el => el.classList.remove('node-merging'));
            const el = document.getElementById(nodeId);
            if(el) {
                el.firstElementChild.classList.add('node-merging');
                el.scrollIntoView({behavior: 'smooth', block: 'center', inline: 'center'});
            }
        }

        function addToBufferDisplay(leafId, text, newLen) {
            elBufferPlaceholder.style.display = 'none';
            elBufferSize.innerText = newLen;
            
            const limit = parseInt(elTargetSize.innerText);
            if (newLen > limit) elBufferSize.classList.add('text-red-600');
            else elBufferSize.classList.remove('text-red-600');

            const div = document.createElement('div');
            div.id = `buf-item-${leafId}`;
            div.className = 'buffer-enter flex-shrink-0 bg-amber-100 text-amber-900 border border-amber-200 px-2 py-1 rounded text-[10px] font-mono whitespace-nowrap overflow-hidden shadow-sm';
            div.innerHTML = visualizeWhitespace(text);
            elBufferContainer.appendChild(div);
        }

        function popFromBufferDisplay(leafId, newLen) {
            elBufferSize.innerText = newLen;
            const el = document.getElementById(`buf-item-${leafId}`);
            if (el) {
                el.classList.add('buffer-exit');
                setTimeout(() => {
                    if(el.parentNode) el.remove();
                    if (elBufferContainer.children.length <= 1) elBufferPlaceholder.style.display = 'block';
                }, 290);
            }
            // Flash overlap indicator
            elOverlapIndicator.style.opacity = '1';
            setTimeout(() => elOverlapIndicator.style.opacity = '0', 500);
        }

        function emitChunkDisplay(text, len) {
            const div = document.createElement('div');
            div.className = 'buffer-enter min-w-[180px] max-w-[220px] h-full bg-white border border-blue-200 rounded-lg p-3 shadow-sm flex flex-col flex-shrink-0';
            
            let displayContent = visualizeWhitespace(text);
            
            div.innerHTML = `
                <div class="flex justify-between items-center mb-2 border-b border-slate-100 pb-1">
                    <span class="text-[10px] font-bold text-blue-500 uppercase flex items-center gap-1"><i data-lucide="check-circle" class="w-3 h-3"></i> Chunk</span>
                    <span class="text-[10px] bg-blue-100 text-blue-700 px-1.5 rounded font-mono">${len} chars</span>
                </div>
                <div class="text-[11px] text-slate-600 font-mono overflow-y-auto custom-scrollbar whitespace-pre-wrap leading-tight h-full bg-slate-50 p-1 rounded border border-slate-100">${displayContent}</div>
            `;
            elFinalChunksContainer.appendChild(div);
            elFinalChunksContainer.scrollLeft = elFinalChunksContainer.scrollWidth;
            log(`>> CHUNK CREATED: ${len} characters`, "success");
        }

        // --- CONTROLLER ---

        function renderStep(stepIndex) {
            const step = appState.trace[stepIndex];
            if (!step) return;

            highlightCodeLine(step.codeLineId);

            switch(step.action) {
                case 'CREATE':
                    createDomNode(step.nodeId, appState.nodes[step.nodeId]);
                    if (step.payload.status) updateNodeStatus(step.nodeId, step.payload.status);
                    if (step.payload.isForced) updateNodeStatus(step.nodeId, 'forced');
                    break;
                case 'STATUS_CHANGE':
                    updateNodeStatus(step.nodeId, step.payload.status, step.payload.separator);
                    break;
                case 'LOG':
                    if(step.payload.msg) log(step.payload.msg, step.payload.type);
                    if (step.codeLineId === 'line-recurse-call') updateNodeStatus(step.nodeId, 'too_long');
                    break;
                case 'IGNORE_NODE':
                    const el = document.getElementById(step.nodeId);
                    if(el) el.classList.add('node-ignored');
                    if(step.payload.msg) log(step.payload.msg, 'gray');
                    break;
                case 'MERGE_HIGHLIGHT':
                    highlightMergingNode(step.nodeId);
                    if(step.payload.msg) log(step.payload.msg);
                    break;
                case 'BUFFER_ADD':
                    addToBufferDisplay(step.payload.leafId, step.payload.text, step.payload.newLen);
                    break;
                case 'BUFFER_POP':
                    popFromBufferDisplay(step.payload.removedId, step.payload.newLen);
                    if(step.payload.msg) log(step.payload.msg, 'bold');
                    break;
                case 'EMIT_CHUNK':
                    emitChunkDisplay(step.payload.text, step.payload.len);
                    break;
            }

            elStepCounter.innerText = `Step: ${stepIndex + 1}`;
        }

        function resetSimulation() {
            // Reset Visuals
            elTreeRoot.innerHTML = '';
            elBufferContainer.innerHTML = '<div class="text-slate-400 text-xs italic w-full text-center mt-10" id="buffer-placeholder">Waiting for merge phase...</div>';
            elFinalChunksContainer.innerHTML = '';
            elConsoleLog.innerHTML = '';
            elBufferSize.innerText = '0';
            elBufferSize.classList.remove('text-red-600');
            
            appState.currentStep = -1;
            
            // Get Values
            const text = elInputText.value;
            const size = parseInt(elChunkSizeInput.value);
            const overlap = parseInt(elChunkOverlapInput.value);
            
            if (overlap >= size) {
                log("Error: Chunk Overlap must be smaller than Chunk Size!", "error");
                return;
            }

            elTargetSize.innerText = size;
            elOverlapSize.innerText = overlap;
            
            // Trace
            const result = generateTrace(text, size, overlap);
            appState.trace = result.trace;
            appState.nodes = result.nodes;
            
            elStatusText.innerText = "Ready";
            elStatusDot.classList.remove('animate-pulse', 'bg-green-500');
            elStatusDot.classList.add('bg-slate-400');
            elStepCounter.innerText = "Step: 0";
            
            btnNext.disabled = false;
            btnPrev.disabled = true;
            highlightCodeLine(null);
        }

        function nextStep() {
            if (appState.currentStep < appState.trace.length - 1) {
                appState.currentStep++;
                renderStep(appState.currentStep);
                btnPrev.disabled = false;
            }
            if (appState.currentStep === appState.trace.length - 1) {
                btnNext.disabled = true;
                stopAutoPlay();
                elStatusText.innerText = "Finished";
                elStatusDot.classList.remove('animate-pulse');
                elStatusDot.classList.add('bg-green-500');
            }
        }

        function prevStep() {
            if (appState.currentStep > 0) {
                const target = appState.currentStep - 1;
                // Quick reset logic for "undo"
                elTreeRoot.innerHTML = '';
                elBufferContainer.innerHTML = '<div class="text-slate-400 text-xs italic w-full text-center mt-10" id="buffer-placeholder">Waiting for merge phase...</div>';
                elFinalChunksContainer.innerHTML = '';
                elConsoleLog.innerHTML = '';
                
                for (let i = 0; i <= target; i++) {
                    renderStep(i);
                }
                appState.currentStep = target;
                btnNext.disabled = false;
            } else {
                resetSimulation();
            }
        }

        function startAutoPlay() {
            if (appState.autoPlayInterval) return;
            elStatusText.innerText = "Running...";
            elStatusDot.classList.remove('bg-slate-400');
            elStatusDot.classList.add('bg-green-500', 'animate-pulse');
            
            appState.autoPlayInterval = setInterval(() => {
                if (appState.currentStep < appState.trace.length - 1) {
                    nextStep();
                } else {
                    stopAutoPlay();
                }
            }, 80); 
        }

        function stopAutoPlay() {
            if (appState.autoPlayInterval) {
                clearInterval(appState.autoPlayInterval);
                appState.autoPlayInterval = null;
                chkAutoPlay.checked = false;
                if(appState.currentStep < appState.trace.length - 1) {
                    elStatusText.innerText = "Paused";
                    elStatusDot.classList.remove('animate-pulse');
                }
            }
        }

        // --- EVENTS ---
        // btnStart.addEventListener('click', () => { resetSimulation(); nextStep(); });
        btnReset.addEventListener('click', () => { stopAutoPlay(); resetSimulation(); });
        btnNext.addEventListener('click', () => { stopAutoPlay(); nextStep(); });
        btnPrev.addEventListener('click', () => { stopAutoPlay(); prevStep(); });
        chkAutoPlay.addEventListener('change', (e) => { e.target.checked ? startAutoPlay() : stopAutoPlay(); });

        elInputText.addEventListener('input', () => stopAutoPlay());
        
        elChunkSizeInput.addEventListener('input', (e) => { 
            elChunkSizeVal.innerText = e.target.value; 
            stopAutoPlay(); 
            resetSimulation(); 
        });

        elChunkOverlapInput.addEventListener('input', (e) => {
            elChunkOverlapVal.innerText = e.target.value;
            stopAutoPlay();
            resetSimulation();
        });

        // --- INIT ---
        elInputText.value = DEFAULT_TEXT;
        lucide.createIcons();
        resetSimulation();

    </script>
</body>
</html>